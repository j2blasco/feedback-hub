#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Recursively scans a directory for boundaries.json files
 */
function scanForBoundariesFiles(dir, srcRoot) {
  const elements = [];
  
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory()) {
        // Recursively scan subdirectories
        elements.push(...scanForBoundariesFiles(fullPath, srcRoot));
      } else if (entry.name === 'boundaries.json') {
        // Found a boundaries.json file
        try {
          const configContent = fs.readFileSync(fullPath, 'utf8');
          const config = JSON.parse(configContent);
          
          // Calculate relative path from src root
          const relativePath = path.relative(srcRoot, dir);
          // Convert to POSIX path format
          const posixPath = relativePath.split(path.sep).join('/');
          
          elements.push({
            type: config.type,
            pattern: `src/${posixPath}/*`,
            folderPath: posixPath
          });
          
          console.log(`Found boundaries.json: ${fullPath} -> type: ${config.type}`);
        } catch (error) {
          console.error(`Error parsing boundaries.json at ${fullPath}:`, error);
        }
      }
    }
  } catch (error) {
    console.error(`Error scanning directory ${dir}:`, error);
  }
  
  return elements;
}

/**
 * Loads boundaries configurations from all found boundaries.json files
 */
function loadBoundariesConfigs(srcRoot) {
  const configs = new Map();
  
  function scanDirectory(dir) {
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory()) {
          scanDirectory(fullPath);
        } else if (entry.name === 'boundaries.json') {
          try {
            const configContent = fs.readFileSync(fullPath, 'utf8');
            const config = JSON.parse(configContent);
            configs.set(config.type, config);
          } catch (error) {
            console.error(`Error parsing boundaries.json at ${fullPath}:`, error);
          }
        }
      }
    } catch (error) {
      console.error(`Error scanning directory ${dir}:`, error);
    }
  }
  
  scanDirectory(srcRoot);
  return configs;
}

/**
 * Generates ESLint boundaries configuration
 */
function generateESLintConfig() {
  const srcPath = path.join(__dirname, 'src');
  
  if (!fs.existsSync(srcPath)) {
    console.error('src directory not found!');
    process.exit(1);
  }
  
  // Scan for boundary elements
  const elements = scanForBoundariesFiles(srcPath, srcPath);
  
  if (elements.length === 0) {
    console.log('No boundaries.json files found. Generating empty configuration.');
  }
  
  // Load all boundaries configurations
  const boundariesConfigs = loadBoundariesConfigs(srcPath);
  
  // Generate rules
  const rules = [];
  
  for (const element of elements) {
    const config = boundariesConfigs.get(element.type);
    if (config) {
      rules.push({
        from: element.type,
        allow: config.allow
      });
    }
  }
  
  // Generate the ESLint configuration
  const eslintConfig = `// This file is auto-generated by generate-eslint-boundaries.js
// Do not edit manually!

import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const boundaries = require('eslint-plugin-boundaries');

export default [
  {
    files: ['src/**/*.ts', 'src/**/*.tsx', 'src/**/*.js', 'src/**/*.mjs'],
    plugins: {
      boundaries
    },
    settings: {
      'boundaries/elements': [
${elements.map(element => `        { type: '${element.type}', pattern: '${element.pattern}' }`).join(',\n')}
      ]
    },
    rules: {
      'boundaries/element-types': [
        2,
        {
          default: 'disallow',
          rules: [
${rules.map(rule => `            { from: '${rule.from}', allow: [${rule.allow.map(a => `'${a}'`).join(', ')}] }`).join(',\n')}
          ]
        }
      ]
    }
  }
];
`;
  
  return eslintConfig;
}

/**
 * Main function
 */
function main() {
  console.log('Generating ESLint boundaries configuration...');
  
  try {
    const config = generateESLintConfig();
    const outputPath = path.join(__dirname, 'eslint.config.generated.mjs');
    
    fs.writeFileSync(outputPath, config, 'utf8');
    
    console.log(`ESLint boundaries configuration generated: ${outputPath}`);
    console.log('Configuration is idempotent and will overwrite existing file.');
  } catch (error) {
    console.error('Error generating ESLint configuration:', error);
    process.exit(1);
  }
}

// Run the script
if (require.main === module) {
  main();
}